{"ast":null,"code":"import { Circle, ParticlesInteractorBase, getDistances, getLinkRandomColor } from \"tsparticles-engine\";\nimport { CircleWarp } from \"./CircleWarp\";\nimport { Links } from \"./Options/Classes/Links\";\nfunction getLinkDistance(pos1, pos2, optDistance, canvasSize, warp) {\n  const {\n    dx,\n    dy,\n    distance\n  } = getDistances(pos1, pos2);\n  if (!warp || distance <= optDistance) {\n    return distance;\n  }\n  const absDiffs = {\n      x: Math.abs(dx),\n      y: Math.abs(dy)\n    },\n    warpDistances = {\n      x: Math.min(absDiffs.x, canvasSize.width - absDiffs.x),\n      y: Math.min(absDiffs.y, canvasSize.height - absDiffs.y)\n    };\n  return Math.sqrt(warpDistances.x ** 2 + warpDistances.y ** 2);\n}\nexport class Linker extends ParticlesInteractorBase {\n  constructor(container) {\n    super(container);\n    this._setColor = p1 => {\n      if (!p1.options.links) {\n        return;\n      }\n      const container = this.linkContainer,\n        linksOptions = p1.options.links;\n      let linkColor = linksOptions.id === undefined ? container.particles.linksColor : container.particles.linksColors.get(linksOptions.id);\n      if (linkColor) {\n        return;\n      }\n      const optColor = linksOptions.color;\n      linkColor = getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);\n      if (linksOptions.id === undefined) {\n        container.particles.linksColor = linkColor;\n      } else {\n        container.particles.linksColors.set(linksOptions.id, linkColor);\n      }\n    };\n    this.linkContainer = container;\n  }\n  clear() {}\n  init() {\n    this.linkContainer.particles.linksColor = undefined;\n    this.linkContainer.particles.linksColors = new Map();\n  }\n  async interact(p1) {\n    var _p1$retina$linksDista;\n    if (!p1.options.links) {\n      return;\n    }\n    p1.links = [];\n    const pos1 = p1.getPosition(),\n      container = this.container,\n      canvasSize = container.canvas.size;\n    if (pos1.x < 0 || pos1.y < 0 || pos1.x > canvasSize.width || pos1.y > canvasSize.height) {\n      return;\n    }\n    const linkOpt1 = p1.options.links,\n      optOpacity = linkOpt1.opacity,\n      optDistance = (_p1$retina$linksDista = p1.retina.linksDistance) !== null && _p1$retina$linksDista !== void 0 ? _p1$retina$linksDista : 0,\n      warp = linkOpt1.warp,\n      range = warp ? new CircleWarp(pos1.x, pos1.y, optDistance, canvasSize) : new Circle(pos1.x, pos1.y, optDistance),\n      query = container.particles.quadTree.query(range);\n    for (const p2 of query) {\n      const linkOpt2 = p2.options.links;\n      if (p1 === p2 || !(linkOpt2 !== null && linkOpt2 !== void 0 && linkOpt2.enable) || linkOpt1.id !== linkOpt2.id || p2.spawning || p2.destroyed || !p2.links || p1.links.some(t => t.destination === p2) || p2.links.some(t => t.destination === p1)) {\n        continue;\n      }\n      const pos2 = p2.getPosition();\n      if (pos2.x < 0 || pos2.y < 0 || pos2.x > canvasSize.width || pos2.y > canvasSize.height) {\n        continue;\n      }\n      const distance = getLinkDistance(pos1, pos2, optDistance, canvasSize, warp && linkOpt2.warp);\n      if (distance > optDistance) {\n        continue;\n      }\n      const opacityLine = (1 - distance / optDistance) * optOpacity;\n      this._setColor(p1);\n      p1.links.push({\n        destination: p2,\n        opacity: opacityLine\n      });\n    }\n  }\n  isEnabled(particle) {\n    var _particle$options$lin;\n    return !!((_particle$options$lin = particle.options.links) !== null && _particle$options$lin !== void 0 && _particle$options$lin.enable);\n  }\n  loadParticlesOptions(options) {\n    if (!options.links) {\n      options.links = new Links();\n    }\n    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      sources[_key - 1] = arguments[_key];\n    }\n    for (const source of sources) {\n      var _ref, _source$links;\n      options.links.load((_ref = (_source$links = source === null || source === void 0 ? void 0 : source.links) !== null && _source$links !== void 0 ? _source$links : source === null || source === void 0 ? void 0 : source.lineLinked) !== null && _ref !== void 0 ? _ref : source === null || source === void 0 ? void 0 : source.line_linked);\n    }\n  }\n  reset() {}\n}","map":{"version":3,"names":["Circle","ParticlesInteractorBase","getDistances","getLinkRandomColor","CircleWarp","Links","getLinkDistance","pos1","pos2","optDistance","canvasSize","warp","dx","dy","distance","absDiffs","x","Math","abs","y","warpDistances","min","width","height","sqrt","Linker","constructor","container","_setColor","p1","options","links","linkContainer","linksOptions","linkColor","id","undefined","particles","linksColor","linksColors","get","optColor","color","blink","consent","set","clear","init","Map","interact","_p1$retina$linksDista","getPosition","canvas","size","linkOpt1","optOpacity","opacity","retina","linksDistance","range","query","quadTree","p2","linkOpt2","enable","spawning","destroyed","some","t","destination","opacityLine","push","isEnabled","particle","_particle$options$lin","loadParticlesOptions","_len","arguments","length","sources","Array","_key","source","_ref","_source$links","load","lineLinked","line_linked","reset"],"sources":["C:/Users/Sutirtha Choudhury/OneDrive/Desktop/Portfolio/my-port-folio/node_modules/tsparticles-interaction-particles-links/esm/Linker.js"],"sourcesContent":["import { Circle, ParticlesInteractorBase, getDistances, getLinkRandomColor, } from \"tsparticles-engine\";\nimport { CircleWarp } from \"./CircleWarp\";\nimport { Links } from \"./Options/Classes/Links\";\nfunction getLinkDistance(pos1, pos2, optDistance, canvasSize, warp) {\n    const { dx, dy, distance } = getDistances(pos1, pos2);\n    if (!warp || distance <= optDistance) {\n        return distance;\n    }\n    const absDiffs = {\n        x: Math.abs(dx),\n        y: Math.abs(dy),\n    }, warpDistances = {\n        x: Math.min(absDiffs.x, canvasSize.width - absDiffs.x),\n        y: Math.min(absDiffs.y, canvasSize.height - absDiffs.y),\n    };\n    return Math.sqrt(warpDistances.x ** 2 + warpDistances.y ** 2);\n}\nexport class Linker extends ParticlesInteractorBase {\n    constructor(container) {\n        super(container);\n        this._setColor = (p1) => {\n            if (!p1.options.links) {\n                return;\n            }\n            const container = this.linkContainer, linksOptions = p1.options.links;\n            let linkColor = linksOptions.id === undefined\n                ? container.particles.linksColor\n                : container.particles.linksColors.get(linksOptions.id);\n            if (linkColor) {\n                return;\n            }\n            const optColor = linksOptions.color;\n            linkColor = getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);\n            if (linksOptions.id === undefined) {\n                container.particles.linksColor = linkColor;\n            }\n            else {\n                container.particles.linksColors.set(linksOptions.id, linkColor);\n            }\n        };\n        this.linkContainer = container;\n    }\n    clear() {\n    }\n    init() {\n        this.linkContainer.particles.linksColor = undefined;\n        this.linkContainer.particles.linksColors = new Map();\n    }\n    async interact(p1) {\n        if (!p1.options.links) {\n            return;\n        }\n        p1.links = [];\n        const pos1 = p1.getPosition(), container = this.container, canvasSize = container.canvas.size;\n        if (pos1.x < 0 || pos1.y < 0 || pos1.x > canvasSize.width || pos1.y > canvasSize.height) {\n            return;\n        }\n        const linkOpt1 = p1.options.links, optOpacity = linkOpt1.opacity, optDistance = p1.retina.linksDistance ?? 0, warp = linkOpt1.warp, range = warp\n            ? new CircleWarp(pos1.x, pos1.y, optDistance, canvasSize)\n            : new Circle(pos1.x, pos1.y, optDistance), query = container.particles.quadTree.query(range);\n        for (const p2 of query) {\n            const linkOpt2 = p2.options.links;\n            if (p1 === p2 ||\n                !linkOpt2?.enable ||\n                linkOpt1.id !== linkOpt2.id ||\n                p2.spawning ||\n                p2.destroyed ||\n                !p2.links ||\n                p1.links.some((t) => t.destination === p2) ||\n                p2.links.some((t) => t.destination === p1)) {\n                continue;\n            }\n            const pos2 = p2.getPosition();\n            if (pos2.x < 0 || pos2.y < 0 || pos2.x > canvasSize.width || pos2.y > canvasSize.height) {\n                continue;\n            }\n            const distance = getLinkDistance(pos1, pos2, optDistance, canvasSize, warp && linkOpt2.warp);\n            if (distance > optDistance) {\n                continue;\n            }\n            const opacityLine = (1 - distance / optDistance) * optOpacity;\n            this._setColor(p1);\n            p1.links.push({\n                destination: p2,\n                opacity: opacityLine,\n            });\n        }\n    }\n    isEnabled(particle) {\n        return !!particle.options.links?.enable;\n    }\n    loadParticlesOptions(options, ...sources) {\n        if (!options.links) {\n            options.links = new Links();\n        }\n        for (const source of sources) {\n            options.links.load(source?.links ?? source?.lineLinked ?? source?.line_linked);\n        }\n    }\n    reset() {\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}